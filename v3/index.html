<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tic-Tac-Toe</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#10b981;
    --muted:#9aa4b2;
    --glass: rgba(255,255,255,0.03);
    --win: rgba(16,185,129,0.12);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    background: linear-gradient(180deg,#071126 0%, #071a21 60%), var(--bg);
    color:#e6eef6;
    display:grid;
    place-items:center;
    padding:24px;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .card{
    width:100%;
    max-width:820px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:20px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    border: 1px solid rgba(255,255,255,0.03);
  }

  header{
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    margin-bottom:14px;
  }
  header h1{
    font-size:20px;
    margin:0;
    letter-spacing:0.2px;
  }
  .controls{
    display:flex;
    gap:8px;
    align-items:center;
  }
  select, button{
    background:var(--glass);
    color:var(--muted);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  .mode{color:var(--muted); font-size:13px;}
  .board-wrap{
    display:grid;
    grid-template-columns: 1fr 280px;
    gap:18px;
    align-items:start;
  }

  /* board */
  .board{
    width:100%;
    aspect-ratio:1/1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border-radius:10px;
    padding:12px;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
    user-select:none;
  }
  .cell{
    background:rgba(255,255,255,0.02);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:48px;
    font-weight:800;
    color:#e6eef6;
    cursor:pointer;
    transition:transform .12s ease, background .12s ease;
  }
  .cell:hover{ transform:translateY(-6px); }
  .cell.disabled{ cursor:not-allowed; opacity:0.9; transform:none; }
  .cell.x{ color:#f97316; } /* orange */
  .cell.o{ color:#60a5fa; } /* blue */

  /* side panel */
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));
    padding:14px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.02);
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .status{
    padding:10px;
    border-radius:8px;
    background:rgba(255,255,255,0.01);
    font-weight:700;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .scores{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .score{
    background:rgba(255,255,255,0.02);
    padding:8px 12px;
    border-radius:8px;
    font-weight:700;
  }
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .hint{font-size:13px;color:var(--muted)}
  footer{margin-top:10px;font-size:13px;color:var(--muted);text-align:center}

  .winner-line{
    position:relative;
    border-radius:8px;
    background:var(--win);
    padding:8px;
    text-align:center;
    font-weight:800;
    color:var(--accent);
  }

  @media (max-width:880px){
    .board-wrap{ grid-template-columns: 1fr; }
    .panel{ order:2 }
    .board{ order:1; margin-bottom:8px; }
  }

  /* simple focus ring for accessibility */
  .cell:focus{
    outline:3px solid rgba(96,165,250,0.12);
    outline-offset:4px;
  }
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Tic Tac Toe game">
    <header>
      <h1>Tic-Tac-Toe</h1>
      <div class="controls">
        <label class="mode" for="modeSelect">Mode</label>
        <select id="modeSelect" aria-label="Game mode">
          <option value="pvp">2 Players (Local)</option>
          <option value="pve">1 Player (vs CPU)</option>
        </select>
        <button id="newBtn" title="Start new match">New Match</button>
        <button id="resetScore" title="Reset scores">Reset Scores</button>
      </div>
    </header>

    <div class="board-wrap">
      <div class="board" id="board" role="grid" aria-label="Tic Tac Toe board">
        <!-- 9 cells generated by JS -->
      </div>

      <aside class="panel" aria-live="polite">
        <div class="status" id="statusBar">
          <div id="turnText">Turn: <strong id="turnName">X</strong></div>
          <div class="hint" id="hint">Make a move</div>
        </div>

        <div class="scores" aria-hidden="false">
          <div class="score">X: <span id="scoreX">0</span></div>
          <div class="score">O: <span id="scoreO">0</span></div>
          <div class="score">Draws: <span id="scoreD">0</span></div>
        </div>

        <div class="actions">
          <button id="undoBtn" disabled>Undo Move</button>
          <button id="randomBtn">Make Random Move</button>
        </div>

        <div class="hint" id="gameHelp">
          - Use keyboard arrows + Enter to navigate cells.<br>
          - In 1-player, CPU is <strong>O</strong> by default.
        </div>

        <div id="lastResult" aria-atomic="true"></div>
      </aside>
    </div>

    <footer>
      Built for practice â€¢ Scores saved in your browser
    </footer>
  </div>

<script>
/*
  Simple Tic-Tac-Toe with:
   - 1p vs simple CPU (random + win/block)
   - 2p local
   - undo, random move, scores persisted in localStorage
   - keyboard navigation (arrow keys + Enter)
*/

const ELEMENTS = {
  board: document.getElementById('board'),
  mode: document.getElementById('modeSelect'),
  newBtn: document.getElementById('newBtn'),
  resetScore: document.getElementById('resetScore'),
  turnText: document.getElementById('turnText'),
  turnName: document.getElementById('turnName'),
  hint: document.getElementById('hint'),
  scoreX: document.getElementById('scoreX'),
  scoreO: document.getElementById('scoreO'),
  scoreD: document.getElementById('scoreD'),
  undoBtn: document.getElementById('undoBtn'),
  randomBtn: document.getElementById('randomBtn'),
  lastResult: document.getElementById('lastResult')
};

const WINNING_LINES = [
  [0,1,2],[3,4,5],[6,7,8], // rows
  [0,3,6],[1,4,7],[2,5,8], // cols
  [0,4,8],[2,4,6]          // diagonals
];

let boardState = Array(9).fill(null); // 'X' | 'O' | null
let currentPlayer = 'X';
let mode = 'pvp';
let scores = { X:0, O:0, D:0 };
let history = [];
let cells = []; // DOM refs
let focusedIndex = 0;

function saveScores(){
  try{ localStorage.setItem('ttt_scores', JSON.stringify(scores)); }catch(e){}
}
function loadScores(){
  try{
    const s = JSON.parse(localStorage.getItem('ttt_scores')||'{}');
    scores = Object.assign(scores, s);
  }catch(e){}
}
function renderScores(){
  ELEMENTS.scoreX.textContent = scores.X;
  ELEMENTS.scoreO.textContent = scores.O;
  ELEMENTS.scoreD.textContent = scores.D;
}

function createBoard(){
  ELEMENTS.board.innerHTML = '';
  cells = [];
  for(let i=0;i<9;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.tabIndex = 0;
    c.setAttribute('role','button');
    c.setAttribute('aria-label', `Cell ${i+1}`);
    c.dataset.index = i;
    c.addEventListener('click', ()=> handleCellClick(i));
    c.addEventListener('keydown', (ev)=> {
      // Enter to play
      if(ev.key === 'Enter' || ev.key === ' '){
        ev.preventDefault();
        handleCellClick(i);
      }
    });
    ELEMENTS.board.appendChild(c);
    cells.push(c);
  }
}

function resetBoard(keepScores=false){
  boardState.fill(null);
  history = [];
  currentPlayer = 'X';
  focusedIndex = 0;
  renderBoard();
  updateStatus('New game â€” X to start');
  ELEMENTS.undoBtn.disabled = true;
  if(!keepScores) { scores = {X:0,O:0,D:0}; saveScores(); renderScores(); }
}

function renderBoard(){
  for(let i=0;i<9;i++){
    const val = boardState[i];
    const el = cells[i];
    el.classList.toggle('x', val === 'X');
    el.classList.toggle('o', val === 'O');
    el.textContent = val? val : '';
    el.classList.toggle('disabled', !!val);
  }
  ELEMENTS.turnName.textContent = currentPlayer;
}

function updateStatus(txt, hint='Make a move'){
  ELEMENTS.hint.textContent = hint;
  ELEMENTS.lastResult.innerHTML = txt ? `<div class="winner-line">${txt}</div>` : '';
}

function checkWinner(state){
  for(const line of WINNING_LINES){
    const [a,b,c] = line;
    if(state[a] && state[a] === state[b] && state[a] === state[c]){
      return { winner: state[a], line };
    }
  }
  if(state.every(Boolean)) return { winner: 'draw' };
  return null;
}

function applyMove(index, player){
  if(boardState[index]) return false;
  boardState[index] = player;
  history.push({index, player});
  ELEMENTS.undoBtn.disabled = false;
  return true;
}

function handleCellClick(i){
  if(mode === 'pve' && currentPlayer === 'O') return; // wait for CPU
  playTurn(i);
}

function playTurn(i){
  if(boardState[i]) return;
  applyMove(i, currentPlayer);
  renderBoard();

  const result = checkWinner(boardState);
  if(result){
    finalize(result);
    return;
  }
  // switch
  currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
  renderBoard();
  updateStatus(`Turn: ${currentPlayer}`, mode === 'pve' && currentPlayer === 'O' ? 'CPU thinking...' : 'Your move');

  if(mode === 'pve' && currentPlayer === 'O'){
    // slight delay so user perceives CPU
    setTimeout(cpuMove, 400 + Math.random()*300);
  }
}

function finalize(result){
  if(result.winner === 'draw'){
    scores.D++;
    updateStatus('Draw! ðŸŽ²', 'Game over â€” draw');
  } else {
    scores[result.winner]++;
    updateStatus(`${result.winner} wins!`, `Winning line: ${result.line.join(',')}`);
    // highlight winning cells
    for(const idx of result.line) cells[idx].style.boxShadow = '0 6px 20px rgba(0,0,0,0.6) inset';
  }
  saveScores();
  renderScores();
  ELEMENTS.undoBtn.disabled = true;
  // block further clicks by marking disabled
  for(const c of cells) c.classList.add('disabled');
}

function cpuMove(){
  // Simple CPU: win if possible, block if necessary, else random
  const cpu = 'O', human = 'X';
  // try winning
  let move = findBestMove(cpu) || findBestMove(human) || pickRandomEmpty();
  if(move != null){
    applyMove(move, cpu);
    renderBoard();
    const result = checkWinner(boardState);
    if(result) { finalize(result); return; }
    currentPlayer = 'X';
    renderBoard();
    updateStatus('Your turn â€” X', 'Make your move');
  }
}

function findBestMove(player){
  // find a line where two are player and one empty -> win/block
  for(const line of WINNING_LINES){
    const [a,b,c] = line;
    const vals = [boardState[a], boardState[b], boardState[c]];
    const countPlayer = vals.filter(v=>v===player).length;
    const emptyIdx = [a,b,c].find(idx=>!boardState[idx]);
    if(countPlayer === 2 && emptyIdx !== undefined) return emptyIdx;
  }
  return null;
}

function pickRandomEmpty(){
  const empties = boardState.map((v,i)=> v ? null : i).filter(v=>v!==null);
  if(empties.length === 0) return null;
  return empties[Math.floor(Math.random()*empties.length)];
}

// UI Buttons
ELEMENTS.newBtn.addEventListener('click', ()=> {
  resetBoard(true);
});
ELEMENTS.resetScore.addEventListener('click', ()=> {
  if(confirm('Reset scores to zero?')){ scores = {X:0,O:0,D:0}; saveScores(); renderScores(); }
});
ELEMENTS.mode.addEventListener('change', (e)=> {
  mode = e.target.value;
  resetBoard(true);
  updateStatus(`Mode: ${mode === 'pve' ? '1 Player (vs CPU)' : '2 Players'}`);
});

ELEMENTS.undoBtn.addEventListener('click', ()=> {
  if(history.length === 0) return;
  // undo last move (and if pve, undo CPU move too)
  const last = history.pop(); boardState[last.index] = null;
  if(mode === 'pve' && last.player === 'O' && history.length){
    const last2 = history.pop(); boardState[last2.index] = null;
  }
  currentPlayer = 'X';
  renderBoard();
  ELEMENTS.undoBtn.disabled = history.length === 0;
  updateStatus('Move undone');
});

ELEMENTS.randomBtn.addEventListener('click', ()=> {
  const idx = pickRandomEmpty();
  if(idx != null) playTurn(idx);
});

// keyboard navigation across cells
document.addEventListener('keydown', (ev)=>{
  const key = ev.key;
  const cols = 3;
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(key)){
    ev.preventDefault();
    if(key === 'ArrowLeft') focusedIndex = (focusedIndex + 8) % 9;
    if(key === 'ArrowRight') focusedIndex = (focusedIndex + 1) % 9;
    if(key === 'ArrowUp') focusedIndex = (focusedIndex + 9 - cols) % 9;
    if(key === 'ArrowDown') focusedIndex = (focusedIndex + cols) % 9;
    cells[focusedIndex].focus();
  }
});

// initial load
function init(){
  loadScores();
  renderScores();
  createBoard();
  resetBoard(true);
  // make first cell focused for keyboard users
  setTimeout(()=> cells[0].focus(), 200);
}
init();

</script>
</body>
</html>